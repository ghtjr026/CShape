# Phase 1 — 객체지향 설계 전환
## (상속 중심 → interface + 의존성 역전)

---

## Phase 1의 최종 목표

Phase 1 학습 후 최종 목표
* C# 코드에서 `interface`가 왜 기본인지 설명할 수 있다
* “new를 어디서 해야 하는지” 스스로 판단할 수 있다
* 클래스 간 의존 방향을 **의식적으로 설계**한다
* C++의 “구현 상속” 습관을 버린다
* 이후 Phase의 **DI / 테스트 / Web API 구조가 자연스럽게 연결**된다

> ❗ Phase 1은
> “객체지향 문법을 배우는 단계”가 아니라
> **“의존성을 다루는 사고방식을 바꾸는 단계”**다

---

# 1. C#에서 상속이 기본이 아닌 이유
## 1.1 C++식 상속 사고

```cpp
class Logger {
public:
    virtual void log(const std::string& msg);
};

class FileLogger : public Logger {
};
```

* “공통 기능이 있으니 상속”
* 매우 자연스러운 사고

---

## 1.2 C#에서 같은 사고를 쓰면 생기는 문제

```csharp
class Logger
{
    public virtual void Log(string msg) { }
}

class FileLogger : Logger
{
}
```

겉보기엔 문제 없어 보이지만:

* 구현과 계약이 결합됨
* 테스트에서 대체 어려움
* 확장 시 ripple effect 발생

📌 **C#에서는 상속 = 강한 결합**

---

## 1.3 C#의 기본 철학

> **상속은 “is-a”가 아니라
> “framework 확장용”일 때만 쓴다**

일반적인 애플리케이션 설계에서는:

* ❌ class → class 상속
* ✅ interface → class 구현

---

# 2. interface는 “계약”이다
## 2.1 interface의 본질

```csharp
public interface ILogger
{
    void Log(string message);
}
```

* 구현 ❌
* 상태 ❌
* **약속만 정의**

📌 C++의 pure virtual class와 유사하지만,
C#에서는 **기본 설계 단위**

---

## 2.2 구현은 언제든 바뀔 수 있다

```csharp
class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine(message);
    }
}
```

```csharp
class FileLogger : ILogger
{
    public void Log(string message)
    {
        File.AppendAllText("log.txt", message);
    }
}
```

📌 사용하는 쪽은 **아무것도 바뀌지 않는다**

---

# 3. 의존성 문제를 정확히 이해하기
## 3.1 잘못된 의존성 (C++식 습관)

```csharp
class OrderService
{
    private readonly ConsoleLogger _logger = new ConsoleLogger();
}
```

문제점:

* 구현에 직접 의존
* 테스트 불가
* 교체 불가

📌 C++에서 `new`를 아무 데서나 하던 습관과 동일

---

## 3.2 의존성 역전 개념

> **고수준 정책이
> 저수준 구현에 의존하면 안 된다**

---

## 3.3 올바른 구조

```csharp
class OrderService
{
    private readonly ILogger _logger;

    public OrderService(ILogger logger)
    {
        _logger = logger;
    }
}
```

* OrderService는 **ILogger만 안다**
* 구현은 외부에서 주입

📌 이게 Phase 1의 핵심이다

---

# 4. “new”는 죄다? 아니다. 위치가 중요하다
## 4.1 new를 써도 되는 곳

* Program / Composition Root
* 테스트 코드
* Factory 내부

## 4.2 new를 쓰면 안 되는 곳

* 서비스 로직
* 비즈니스 규칙
* 도메인 객체 내부

📌 **new = 의존성 고정**

---

# 5. 생성자 주입(Constructor Injection)

```csharp
class PaymentService
{
    private readonly ILogger _logger;

    public PaymentService(ILogger logger)
    {
        _logger = logger;
    }
}
```

### 특징

* 의존성 명확
* 테스트 용이
* 불변 상태 유지

📌 C++의 “생성자에서 참조 받기”와 비슷하지만
C#에서는 **표준 패턴**

---

# 6. interface 분리 원칙 (ISP)
## 6.1 잘못된 interface

```csharp
interface IService
{
    void Log();
    void Save();
    void Send();
}
```

* 너무 큼
* 구현 강제

---

## 6.2 올바른 분리

```csharp
interface ILogger { void Log(string msg); }
interface IRepository { void Save(); }
interface INotifier { void Send(); }
```

📌 **작고 명확한 계약**

---

# 7. 상속이 필요한 “진짜” 경우
## 7.1 프레임워크 확장

```csharp
class MyController : ControllerBase
```

* framework가 base class 제공
* lifecycle이 정해져 있음

## 7.2 Template Method 패턴

```csharp
abstract class Worker
{
    public void Run()
    {
        Setup();
        Execute();
        Cleanup();
    }

    protected abstract void Execute();
}
```

📌 이 외의 상속은 대부분 냄새

---

# 8. C++ 중급자가 자주 하는 실수

❌ interface 없이 class만 사용
❌ 상속으로 기능 재사용
❌ service 내부에서 new
❌ 구현 객체를 public API에 노출
❌ mock이 안 되는 구조

---

# 9. Phase 1 필수 실습 (머릿속으로만 하지 말 것)
### 실습 A

* Logger를 interface로 분리
* Console / File 구현 만들기
* Service에 주입

### 실습 B

* `OrderService` 작성
* Logger 구현 교체해보기
* Service 코드는 **단 한 줄도 수정하지 않기**

---

# 10. Phase 1 완료 자가 진단

아래 질문에 즉시 답할 수 있어야 한다.

* 왜 class 상속보다 interface가 안전한가?
* new를 쓰면 안 되는 이유는?
* 생성자 주입의 장점은?
* 어떤 경우에만 상속을 써야 하는가?
* 이 구조가 테스트에 왜 유리한가?

---

# 11. Phase 1 핵심 요약

* interface는 계약이다
* 구현은 교체 가능해야 한다
* new는 의존성을 고정한다
* 상속은 예외다
* 생성자 주입은 기본이다
